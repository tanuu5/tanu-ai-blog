<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>LABYRINTH 3D</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700;900&family=Cinzel+Decorative:wght@700&display=swap');

  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

  :root {
    --gold: #c9a84c;
    --gold-dim: #7a6130;
    --blood: #8b1a1a;
    --stone: #1a1510;
    --stone-mid: #2a2018;
    --stone-light: #3d3025;
    --fog: rgba(10, 8, 5, 0.95);
  }

  body {
    background: #0a0805;
    color: #d4c5a0;
    font-family: 'Cinzel', serif;
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    user-select: none;
  }

  /* ── TITLE SCREEN ── */
  #titleScreen {
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, #1a1208 0%, #050402 100%);
    display: flex; flex-direction: column;
    align-items: center; justify-content: center;
    z-index: 100;
    transition: opacity 0.8s;
  }
  #titleScreen.hidden { opacity: 0; pointer-events: none; }

  .title-main {
    font-family: 'Cinzel Decorative', serif;
    font-size: clamp(2.5rem, 6vw, 5rem);
    font-weight: 700;
    letter-spacing: 0.3em;
    color: var(--gold);
    text-shadow:
      0 0 20px rgba(201,168,76,0.8),
      0 0 60px rgba(201,168,76,0.3),
      0 2px 4px rgba(0,0,0,0.9);
    margin-bottom: 0.2em;
    animation: titlePulse 3s ease-in-out infinite;
  }
  .title-sub {
    font-size: clamp(0.7rem, 1.5vw, 1rem);
    letter-spacing: 0.6em;
    color: #7a6130;
    margin-bottom: 3em;
    text-transform: uppercase;
  }
  @keyframes titlePulse {
    0%,100% { text-shadow: 0 0 20px rgba(201,168,76,0.8), 0 0 60px rgba(201,168,76,0.3), 0 2px 4px rgba(0,0,0,0.9); }
    50% { text-shadow: 0 0 40px rgba(201,168,76,1), 0 0 100px rgba(201,168,76,0.5), 0 2px 4px rgba(0,0,0,0.9); }
  }

  .title-options { display: flex; gap: 1em; margin-bottom: 2em; }
  .size-btn {
    background: transparent;
    border: 1px solid var(--gold-dim);
    color: var(--gold-dim);
    font-family: 'Cinzel', serif;
    font-size: 0.85rem;
    letter-spacing: 0.2em;
    padding: 0.5em 1.2em;
    cursor: pointer;
    transition: all 0.2s;
  }
  .size-btn:hover, .size-btn.active {
    border-color: var(--gold);
    color: var(--gold);
    background: rgba(201,168,76,0.08);
    box-shadow: 0 0 10px rgba(201,168,76,0.2);
  }

  .start-btn {
    background: transparent;
    border: 2px solid var(--gold);
    color: var(--gold);
    font-family: 'Cinzel', serif;
    font-size: 1.1rem;
    letter-spacing: 0.3em;
    padding: 0.8em 3em;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.3s;
    position: relative;
    overflow: hidden;
  }
  .start-btn::before {
    content: '';
    position: absolute; inset: 0;
    background: var(--gold);
    transform: translateX(-100%);
    transition: transform 0.3s;
    z-index: -1;
  }
  .start-btn:hover { color: #0a0805; }
  .start-btn:hover::before { transform: translateX(0); }

  .controls-hint {
    margin-top: 3em;
    font-size: 0.75rem;
    letter-spacing: 0.15em;
    color: #4a3d28;
    text-align: center;
    line-height: 2;
  }

  /* ── GAME WRAPPER ── */
  #gameWrapper {
    display: none;
    width: 100vw;
    height: 100vh;
    position: relative;
  }

  /* ── 3D CANVAS ── */
  #gameCanvas {
    display: block;
    width: 100%;
    height: 100%;
    image-rendering: pixelated;
  }

  /* ── HUD ── */
  #hud {
    position: fixed;
    top: 0; left: 0; right: 0;
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    padding: 1rem 1.5rem;
    pointer-events: none;
  }

  .hud-panel {
    background: rgba(10,8,5,0.85);
    border: 1px solid var(--gold-dim);
    padding: 0.6rem 1rem;
    backdrop-filter: blur(4px);
  }
  .hud-label {
    font-size: 0.55rem;
    letter-spacing: 0.3em;
    color: var(--gold-dim);
    text-transform: uppercase;
    margin-bottom: 0.2rem;
  }
  .hud-value {
    font-size: 1.2rem;
    color: var(--gold);
    font-weight: 700;
    text-shadow: 0 0 10px rgba(201,168,76,0.5);
  }

  /* ── MINIMAP ── */
  #minimap {
    position: fixed;
    bottom: 1.5rem;
    right: 1.5rem;
    border: 1px solid var(--gold-dim);
    background: rgba(5,4,2,0.9);
    padding: 4px;
  }
  #minimapCanvas { display: block; }

  /* ── CONTROLS ── */
  #controls {
    position: fixed;
    bottom: 1.5rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 4px;
    pointer-events: auto;
  }
  .ctrl-row { display: flex; gap: 4px; }
  .ctrl-btn {
    width: 44px; height: 44px;
    background: rgba(10,8,5,0.85);
    border: 1px solid var(--gold-dim);
    color: var(--gold);
    font-size: 1.1rem;
    display: flex; align-items: center; justify-content: center;
    cursor: pointer;
    transition: all 0.1s;
    touch-action: none;
    -webkit-tap-highlight-color: transparent;
  }
  .ctrl-btn:active, .ctrl-btn.pressed {
    background: rgba(201,168,76,0.15);
    border-color: var(--gold);
  }

  /* ── ACTION BUTTONS ── */
  #actionBar {
    position: fixed;
    top: 0; left: 0; right: 0;
    display: flex;
    justify-content: center;
    gap: 1rem;
    padding: 1rem;
    pointer-events: auto;
  }
  .action-btn {
    background: rgba(10,8,5,0.9);
    border: 1px solid var(--gold-dim);
    color: var(--gold-dim);
    font-family: 'Cinzel', serif;
    font-size: 0.7rem;
    letter-spacing: 0.2em;
    padding: 0.5em 1.2em;
    cursor: pointer;
    text-transform: uppercase;
    transition: all 0.2s;
    pointer-events: auto;
  }
  .action-btn:hover {
    border-color: var(--gold);
    color: var(--gold);
    background: rgba(201,168,76,0.1);
  }
  .action-btn.solve-active {
    border-color: #4fc3f7;
    color: #4fc3f7;
    box-shadow: 0 0 10px rgba(79,195,247,0.3);
  }

  /* ── CROSSHAIR ── */
  #crosshair {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    width: 16px; height: 16px;
    pointer-events: none;
  }
  #crosshair::before, #crosshair::after {
    content: '';
    position: absolute;
    background: rgba(201,168,76,0.7);
  }
  #crosshair::before { width: 100%; height: 1px; top: 50%; left: 0; }
  #crosshair::after { width: 1px; height: 100%; top: 0; left: 50%; }

  /* ── GOAL OVERLAY ── */
  #goalOverlay {
    position: fixed; inset: 0;
    background: rgba(5,4,2,0.92);
    display: none;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 50;
  }
  .goal-title {
    font-family: 'Cinzel Decorative', serif;
    font-size: clamp(2rem, 5vw, 4rem);
    color: var(--gold);
    text-shadow: 0 0 40px rgba(201,168,76,0.8);
    margin-bottom: 0.5em;
    animation: titlePulse 2s infinite;
  }
  .goal-sub { font-size: 0.9rem; letter-spacing: 0.3em; color: var(--gold-dim); margin-bottom: 2.5em; }
  .goal-stats {
    display: flex; gap: 3em;
    margin-bottom: 2.5em;
    border: 1px solid var(--gold-dim);
    padding: 1.5em 3em;
  }
  .stat-item { text-align: center; }
  .stat-val { font-size: 2rem; color: var(--gold); font-weight: 700; }
  .stat-lbl { font-size: 0.6rem; letter-spacing: 0.3em; color: var(--gold-dim); margin-top: 0.3em; }

  /* ── MESSAGE ── */
  #message {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(10,8,5,0.95);
    border: 1px solid var(--gold);
    color: var(--gold);
    font-size: 0.9rem;
    letter-spacing: 0.2em;
    padding: 0.8em 2em;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s;
    text-align: center;
    z-index: 60;
  }
  #message.show { opacity: 1; }

  /* ── TORCH VIGNETTE ── */
  #vignette {
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, transparent 40%, rgba(5,3,1,0.85) 100%);
    pointer-events: none;
    z-index: 5;
  }
  #torchFlicker {
    position: fixed; inset: 0;
    background: radial-gradient(ellipse at center, rgba(201,140,30,0.04) 0%, transparent 70%);
    pointer-events: none;
    z-index: 4;
    animation: flicker 0.15s steps(1) infinite;
  }
  @keyframes flicker {
    0%  { opacity: 1; }
    20% { opacity: 0.88; }
    40% { opacity: 1; }
    60% { opacity: 0.93; }
    80% { opacity: 0.97; }
    100%{ opacity: 1; }
  }
</style>
</head>
<body>

<!-- TITLE SCREEN -->
<div id="titleScreen">
  <div class="title-main">LABYRINTH</div>
  <div class="title-sub">— 3D Dungeon Maze —</div>

  <div style="margin-bottom:1.5em; font-size:0.75rem; letter-spacing:0.25em; color:#4a3d28;">迷路の大きさ</div>
  <div class="title-options">
    <button class="size-btn" data-size="7">SMALL<br><span style="font-size:0.7em;letter-spacing:0">7 × 7</span></button>
    <button class="size-btn active" data-size="11">NORMAL<br><span style="font-size:0.7em;letter-spacing:0">11 × 11</span></button>
    <button class="size-btn" data-size="15">LARGE<br><span style="font-size:0.7em;letter-spacing:0">15 × 15</span></button>
    <button class="size-btn" data-size="21">EPIC<br><span style="font-size:0.7em;letter-spacing:0">21 × 21</span></button>
  </div>

  <button class="start-btn" id="startBtn">ENTER THE MAZE</button>

  <div class="controls-hint">
    W / ↑ &nbsp; 前進 &nbsp;｜&nbsp; S / ↓ &nbsp; 後退 &nbsp;｜&nbsp; A / ← &nbsp; 左回転 &nbsp;｜&nbsp; D / → &nbsp; 右回転<br>
    ゴール（赤く光る扉）まで辿り着け
  </div>
</div>

<!-- GAME -->
<div id="gameWrapper">
  <canvas id="gameCanvas"></canvas>

  <!-- Atmosphere -->
  <div id="vignette"></div>
  <div id="torchFlicker"></div>

  <!-- Crosshair -->
  <div id="crosshair"></div>

  <!-- HUD -->
  <div id="hud">
    <div class="hud-panel">
      <div class="hud-label">タイム</div>
      <div class="hud-value" id="timer">00:00</div>
    </div>
    <div class="hud-panel" style="text-align:center;">
      <div class="hud-label">LABYRINTH 3D</div>
      <div class="hud-value" style="font-size:0.75rem;letter-spacing:0.15em;" id="mazeInfo">—</div>
    </div>
    <div class="hud-panel">
      <div class="hud-label">ステップ</div>
      <div class="hud-value" id="stepCount">0</div>
    </div>
  </div>

  <!-- Action Buttons -->
  <div id="actionBar">
    <button class="action-btn" id="solveBtn">答え合わせ</button>
    <button class="action-btn" id="newMazeBtn">新しい迷路</button>
    <button class="action-btn" id="backBtn">タイトルへ</button>
  </div>

  <!-- Minimap -->
  <div id="minimap">
    <canvas id="minimapCanvas" width="120" height="120"></canvas>
  </div>

  <!-- D-pad -->
  <div id="controls">
    <div class="ctrl-row">
      <button class="ctrl-btn" data-key="forward">▲</button>
    </div>
    <div class="ctrl-row">
      <button class="ctrl-btn" data-key="left">◀</button>
      <button class="ctrl-btn" data-key="back">▼</button>
      <button class="ctrl-btn" data-key="right">▶</button>
    </div>
  </div>

  <!-- Message -->
  <div id="message"></div>

  <!-- Goal Overlay -->
  <div id="goalOverlay">
    <div class="goal-title">脱出成功！</div>
    <div class="goal-sub">— YOU ESCAPED —</div>
    <div class="goal-stats">
      <div class="stat-item">
        <div class="stat-val" id="finalTime">--:--</div>
        <div class="stat-lbl">クリアタイム</div>
      </div>
      <div class="stat-item">
        <div class="stat-val" id="finalSteps">0</div>
        <div class="stat-lbl">ステップ数</div>
      </div>
    </div>
    <button class="start-btn" id="nextMazeBtn">次の迷路へ</button>
    <button class="action-btn" style="margin-top:1rem;" id="backToTitleBtn">タイトルへ戻る</button>
  </div>
</div>

<script>
// ════════════════════════════════════════════
//  MAZE GENERATOR (Recursive Backtracking)
// ════════════════════════════════════════════
function generateMaze(cols, rows) {
  // Work in cell space (half canvas grid); cols/rows must be odd
  const grid = [];
  for (let y = 0; y < rows; y++) {
    grid[y] = [];
    for (let x = 0; x < cols; x++) grid[y][x] = 1; // 1=wall, 0=path
  }
  const dirs = [{dx:2,dy:0},{dx:-2,dy:0},{dx:0,dy:2},{dx:0,dy:-2}];
  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.random()*i|0;[a[i],a[j]]=[a[j],a[i]]}return a;}
  function carve(x,y){
    grid[y][x]=0;
    for(const {dx,dy} of shuffle([...dirs])){
      const nx=x+dx, ny=y+dy;
      if(ny>0&&ny<rows-1&&nx>0&&nx<cols-1&&grid[ny][nx]===1){
        grid[y+dy/2][x+dx/2]=0;
        carve(nx,ny);
      }
    }
  }
  carve(1,1);
  grid[1][0]=0; // entrance
  grid[rows-2][cols-1]=0; // exit
  return grid;
}

// BFS solver
function solveMaze(grid,cols,rows){
  const start={x:1,y:1};
  const goal={x:cols-2,y:rows-2};
  const queue=[{...start,path:[start]}];
  const visited=new Set();
  visited.add(`${start.x},${start.y}`);
  const dirs=[{dx:1,dy:0},{dx:-1,dy:0},{dx:0,dy:1},{dx:0,dy:-1}];
  while(queue.length){
    const {x,y,path}=queue.shift();
    if(x===goal.x&&y===goal.y) return path;
    for(const {dx,dy} of dirs){
      const nx=x+dx,ny=y+dy;
      if(ny>=0&&ny<rows&&nx>=0&&nx<cols&&grid[ny][nx]===0&&!visited.has(`${nx},${ny}`)){
        visited.add(`${nx},${ny}`);
        queue.push({x:nx,y:ny,path:[...path,{x:nx,y:ny}]});
      }
    }
  }
  return [];
}

// ════════════════════════════════════════════
//  RAYCASTER
// ════════════════════════════════════════════
const RC = {
  canvas: null, ctx: null,
  W: 0, H: 0,
  map: [], mapCols: 0, mapRows: 0,
  px: 1.5, py: 1.5,   // player pos
  pa: 0,               // angle (radians)
  fov: Math.PI / 3,
  speed: 0.05,
  rotSpeed: 0.04,
  goalX: 0, goalY: 0,
  solutionPath: null,
  showSolution: false,

  // Key state
  keys: { forward:false, back:false, left:false, right:false },

  // Timing
  startTime: 0,
  steps: 0,
  finished: false,
  timerInterval: null,

  // Texture colors for walls
  WALL_COLORS: {
    light: ['#4a3a2a','#3d3020','#453828','#3a2e1a'],
    dark:  ['#261d12','#1e1810','#22190e','#1c1509'],
    goal:  '#8b1a1a',
  },

  init(canvas, map, cols, rows) {
    this.canvas = canvas;
    this.ctx = canvas.getContext('2d');
    this.resize();
    this.map = map;
    this.mapCols = cols;
    this.mapRows = rows;
    this.px = 1.5; this.py = 1.5;
    this.pa = 0;
    this.solutionPath = null;
    this.showSolution = false;
    this.steps = 0;
    this.finished = false;
    this.startTime = performance.now();
    this.goalX = cols - 2;
    this.goalY = rows - 2;
  },

  resize() {
    if (!this.canvas) return;
    this.W = this.canvas.offsetWidth;
    this.H = this.canvas.offsetHeight;
    this.canvas.width = Math.floor(this.W / 2);  // half-res for performance
    this.canvas.height = Math.floor(this.H / 2);
    this.W = this.canvas.width;
    this.H = this.canvas.height;
  },

  castRay(angle) {
    const cosA = Math.cos(angle), sinA = Math.sin(angle);
    let x = this.px, y = this.py;
    const step = 0.02;
    for (let dist = 0; dist < 30; dist += step) {
      x = this.px + Math.cos(angle) * dist;
      y = this.py + Math.sin(angle) * dist;
      const mx = Math.floor(x), my = Math.floor(y);
      if (mx < 0 || my < 0 || mx >= this.mapCols || my >= this.mapRows) return {dist,hit:'wall',mx,my};
      if (this.map[my][mx] === 1) return {dist,hit:'wall',mx,my};
      if (mx === this.goalX && my === this.goalY) return {dist,hit:'goal',mx,my};
    }
    return {dist:30,hit:'none',mx:Math.floor(x),my:Math.floor(y)};
  },

  render() {
    const { ctx, W, H } = this;

    // Sky (stone ceiling)
    const skyGrad = ctx.createLinearGradient(0, 0, 0, H/2);
    skyGrad.addColorStop(0, '#0a0704');
    skyGrad.addColorStop(1, '#151008');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(0, 0, W, H/2);

    // Floor
    const floorGrad = ctx.createLinearGradient(0, H/2, 0, H);
    floorGrad.addColorStop(0, '#100c07');
    floorGrad.addColorStop(1, '#060401');
    ctx.fillStyle = floorGrad;
    ctx.fillRect(0, H/2, W, H/2);

    // Rays
    const numRays = W;
    const halfFov = this.fov / 2;

    for (let col = 0; col < numRays; col++) {
      const rayAngle = this.pa - halfFov + (col / numRays) * this.fov;
      const {dist, hit} = this.castRay(rayAngle);

      // Fix fisheye
      const corr = dist * Math.cos(rayAngle - this.pa);
      const wallH = Math.min(H, H / corr);
      const wallTop = (H - wallH) / 2;

      // Shading
      const shade = Math.max(0, 1 - corr / 12);
      let baseColor;

      if (hit === 'goal') {
        // Glowing red goal
        const r = Math.floor(180 * shade + 80);
        const g = Math.floor(20 * shade);
        const b = Math.floor(20 * shade);
        baseColor = `rgb(${r},${g},${b})`;
        // Flickering glow
        const glow = Math.abs(Math.sin(Date.now() * 0.003)) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(200,30,30,${shade * glow * 0.15})`;
        ctx.fillRect(col, 0, 1, H);
      } else {
        // Stone wall with banding pattern
        const band = Math.sin(wallTop * 0.1) > 0 ? 0 : 1;
        const palette = this.WALL_COLORS;
        const ci = (Math.floor(this.px * 3 + this.py * 7 + col * 0.01)) % palette.light.length;
        const lc = palette.light[Math.abs(ci) % palette.light.length];
        const dc = palette.dark[Math.abs(ci) % palette.dark.length];
        baseColor = band ? lc : dc;

        // Parse and shade
        const rgb = this.hexShade(baseColor, shade);
        baseColor = rgb;
      }

      if (hit === 'goal') {
        const r = Math.floor(200 * shade + 55);
        ctx.fillStyle = `rgb(${r},${Math.floor(r*0.1)},${Math.floor(r*0.08)})`;
      } else {
        ctx.fillStyle = baseColor;
      }
      ctx.fillRect(col, wallTop, 1, wallH);

      // Darkened edges (ambient occlusion fake)
      const edgeDark = Math.max(0, 1 - Math.abs(col / numRays - 0.5) * 2 * 0.3);
      ctx.fillStyle = `rgba(0,0,0,${(1 - edgeDark) * 0.2})`;
      ctx.fillRect(col, wallTop, 1, wallH);
    }

    // Torch glow effect (radial on floor/ceil edges)
    const cx = W / 2, cy = H / 2;
    const torchR = Math.abs(Math.sin(Date.now() * 0.002)) * 20 + W * 0.35;
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, torchR);
    grad.addColorStop(0, 'rgba(200,130,40,0.06)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, W, H);
  },

  hexShade(hex, shade) {
    // parse #rrggbb
    const r = parseInt(hex.slice(1,3),16);
    const g = parseInt(hex.slice(3,5),16);
    const b = parseInt(hex.slice(5,7),16);
    // add warm torch tint
    const torch = shade * 0.3;
    return `rgb(${Math.floor(r*shade + torch*60)},${Math.floor(g*shade + torch*30)},${Math.floor(b*shade)})`;
  },

  move() {
    if (this.finished) return;
    const { keys, speed, rotSpeed } = this;
    let moved = false;

    if (keys.left)  { this.pa -= rotSpeed; }
    if (keys.right) { this.pa += rotSpeed; }

    let nx = this.px, ny = this.py;
    if (keys.forward) {
      nx += Math.cos(this.pa) * speed;
      ny += Math.sin(this.pa) * speed;
    }
    if (keys.back) {
      nx -= Math.cos(this.pa) * speed;
      ny -= Math.sin(this.pa) * speed;
    }
    if (keys.forward || keys.back) moved = true;

    // Collision
    const margin = 0.25;
    if (this.map[Math.floor(ny)][Math.floor(nx)] === 0 ||
        (Math.floor(nx) === this.goalX && Math.floor(ny) === this.goalY)) {
      this.px = nx; this.py = ny;
    } else {
      // Try sliding
      if (this.map[Math.floor(this.py)][Math.floor(nx)] === 0) this.px = nx;
      if (this.map[Math.floor(ny)][Math.floor(this.px)] === 0) this.py = ny;
    }

    if (moved) this.steps++;

    // Check goal
    if (!this.finished && Math.floor(this.px) === this.goalX && Math.floor(this.py) === this.goalY) {
      this.finished = true;
      onGoal();
    }
  },

  drawMinimap(mmCanvas) {
    const ctx = mmCanvas.getContext('2d');
    const W = mmCanvas.width, H = mmCanvas.height;
    const cw = W / this.mapCols, ch = H / this.mapRows;
    ctx.fillStyle = '#050402';
    ctx.fillRect(0, 0, W, H);

    for (let y = 0; y < this.mapRows; y++) {
      for (let x = 0; x < this.mapCols; x++) {
        if (this.map[y][x] === 1) {
          ctx.fillStyle = '#2a2018';
          ctx.fillRect(x*cw, y*ch, cw, ch);
        }
        if (x === this.goalX && y === this.goalY) {
          ctx.fillStyle = '#8b1a1a';
          ctx.fillRect(x*cw+1, y*ch+1, cw-2, ch-2);
        }
      }
    }

    // Solution path
    if (this.showSolution && this.solutionPath) {
      ctx.fillStyle = 'rgba(79,195,247,0.5)';
      for (const p of this.solutionPath) {
        ctx.fillRect(p.x*cw+cw/4, p.y*ch+ch/4, cw/2, ch/2);
      }
    }

    // Player
    const px = this.px * cw, py = this.py * ch;
    ctx.fillStyle = '#c9a84c';
    ctx.beginPath();
    ctx.arc(px, py, cw * 0.8, 0, Math.PI * 2);
    ctx.fill();

    // Direction
    ctx.strokeStyle = '#c9a84c';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(px, py);
    ctx.lineTo(px + Math.cos(this.pa) * cw * 2, py + Math.sin(this.pa) * ch * 2);
    ctx.stroke();
  }
};

// ════════════════════════════════════════════
//  GAME STATE
// ════════════════════════════════════════════
let mazeCols = 11, mazeRows = 11;
let grid = [];
let animId = null;
let timerInterval = null;
let elapsedSeconds = 0;

function startTimer() {
  clearInterval(timerInterval);
  elapsedSeconds = 0;
  timerInterval = setInterval(() => {
    if (RC.finished) return;
    elapsedSeconds++;
    document.getElementById('timer').textContent = formatTime(elapsedSeconds);
  }, 1000);
}

function formatTime(s) {
  const m = String(Math.floor(s/60)).padStart(2,'0');
  const sec = String(s%60).padStart(2,'0');
  return `${m}:${sec}`;
}

function onGoal() {
  clearInterval(timerInterval);
  document.getElementById('finalTime').textContent = formatTime(elapsedSeconds);
  document.getElementById('finalSteps').textContent = RC.steps;
  setTimeout(() => {
    document.getElementById('goalOverlay').style.display = 'flex';
  }, 600);
}

function initGame(cols, rows) {
  mazeCols = cols; mazeRows = rows;
  // Ensure odd
  if (cols % 2 === 0) mazeCols++;
  if (rows % 2 === 0) mazeRows++;

  grid = generateMaze(mazeCols, mazeRows);
  const canvas = document.getElementById('gameCanvas');
  RC.init(canvas, grid, mazeCols, mazeRows);
  document.getElementById('mazeInfo').textContent = `${mazeCols} × ${mazeRows}`;
  document.getElementById('stepCount').textContent = '0';
  document.getElementById('timer').textContent = '00:00';
  document.getElementById('goalOverlay').style.display = 'none';
  document.getElementById('solveBtn').classList.remove('solve-active');
  startTimer();
}

function gameLoop() {
  RC.move();
  RC.render();
  // Update minimap
  RC.drawMinimap(document.getElementById('minimapCanvas'));
  // Update step counter
  document.getElementById('stepCount').textContent = RC.steps;
  animId = requestAnimationFrame(gameLoop);
}

function showGame() {
  document.getElementById('titleScreen').classList.add('hidden');
  document.getElementById('gameWrapper').style.display = 'block';
  // Resize canvas properly
  setTimeout(() => {
    initGame(mazeCols, mazeRows);
    if (animId) cancelAnimationFrame(animId);
    gameLoop();
  }, 100);
}

function showTitle() {
  clearInterval(timerInterval);
  if (animId) cancelAnimationFrame(animId);
  document.getElementById('goalOverlay').style.display = 'none';
  document.getElementById('gameWrapper').style.display = 'none';
  const ts = document.getElementById('titleScreen');
  ts.classList.remove('hidden');
}

// ════════════════════════════════════════════
//  EVENTS
// ════════════════════════════════════════════

// Title screen
document.querySelectorAll('.size-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.size-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    const s = parseInt(btn.dataset.size);
    mazeCols = s; mazeRows = s;
  });
});
document.getElementById('startBtn').addEventListener('click', showGame);

// Action buttons
document.getElementById('solveBtn').addEventListener('click', () => {
  RC.showSolution = !RC.showSolution;
  const btn = document.getElementById('solveBtn');
  if (RC.showSolution) {
    if (!RC.solutionPath) RC.solutionPath = solveMaze(grid, mazeCols, mazeRows);
    btn.classList.add('solve-active');
    showMessage('解経路を表示中 — ミニマップを確認してください');
  } else {
    btn.classList.remove('solve-active');
    showMessage('解経路を非表示にしました');
  }
});

document.getElementById('newMazeBtn').addEventListener('click', () => {
  document.getElementById('solveBtn').classList.remove('solve-active');
  initGame(mazeCols, mazeRows);
  showMessage('新しい迷路を生成しました');
});

document.getElementById('backBtn').addEventListener('click', showTitle);
document.getElementById('nextMazeBtn').addEventListener('click', () => {
  document.getElementById('goalOverlay').style.display = 'none';
  initGame(mazeCols, mazeRows);
});
document.getElementById('backToTitleBtn').addEventListener('click', showTitle);

// Keyboard
document.addEventListener('keydown', e => {
  switch(e.key) {
    case 'ArrowUp': case 'w': case 'W': RC.keys.forward = true; break;
    case 'ArrowDown': case 's': case 'S': RC.keys.back = true; break;
    case 'ArrowLeft': case 'a': case 'A': RC.keys.left = true; break;
    case 'ArrowRight': case 'd': case 'D': RC.keys.right = true; break;
  }
  e.preventDefault();
}, {passive: false});

document.addEventListener('keyup', e => {
  switch(e.key) {
    case 'ArrowUp': case 'w': case 'W': RC.keys.forward = false; break;
    case 'ArrowDown': case 's': case 'S': RC.keys.back = false; break;
    case 'ArrowLeft': case 'a': case 'A': RC.keys.left = false; break;
    case 'ArrowRight': case 'd': case 'D': RC.keys.right = false; break;
  }
});

// D-pad touch
document.querySelectorAll('.ctrl-btn').forEach(btn => {
  const key = btn.dataset.key;
  const keymap = {forward:'forward', back:'back', left:'left', right:'right'};
  const k = keymap[key];

  btn.addEventListener('pointerdown', e => {
    e.preventDefault();
    RC.keys[k] = true;
    btn.classList.add('pressed');
  });
  btn.addEventListener('pointerup', e => {
    RC.keys[k] = false;
    btn.classList.remove('pressed');
  });
  btn.addEventListener('pointerleave', e => {
    RC.keys[k] = false;
    btn.classList.remove('pressed');
  });
});

// Resize
window.addEventListener('resize', () => {
  if (document.getElementById('gameWrapper').style.display !== 'none') {
    RC.resize();
  }
});

// Message helper
let msgTimeout;
function showMessage(text) {
  const el = document.getElementById('message');
  el.textContent = text;
  el.classList.add('show');
  clearTimeout(msgTimeout);
  msgTimeout = setTimeout(() => el.classList.remove('show'), 2500);
}
</script>
</body>
</html>
